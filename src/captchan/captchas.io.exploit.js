// import axios 
import axios from 'axios';
// waiter
import wait from 'waiting-for-js';
import generateToken from '../utils/generateToken.js';



const captcha_solver = async (page, token, options) => {
    /* this function will solve the captcha using captchas.io service
     * it takes a page and looks for the captcha element
     * then it will send the captcha to the service
     * checks for the response every n seconds
     * then it will fill the captcha element with the response
     * and return true */
    let { checkEvery, timeout, submitEndpoint, checkEndpoint, debug } = options;
    
    // default values
    if(!checkEvery) checkEvery = 5; // seconds
    if(!timeout) timeout = 400; // seconds
    if(!submitEndpoint) submitEndpoint = 'https://api.captchas.io/in.php'
    if(!checkEndpoint) checkEndpoint = 'https://api.captchas.io/res.php'
    if(!debug) debug = false;

    // wait for function to find the callback function
    let result = await page.evaluate( () => {
        if (typeof (___grecaptcha_cfg) !== 'undefined') {
            // eslint-disable-next-line camelcase, no-undef
            return Object.entries(___grecaptcha_cfg.clients).map(([cid, client]) => {
                const data = { id: cid, version: cid >= 10000 ? 'V3' : 'V2' };
                const objects = Object.entries(client).filter(([_, value]) => value && typeof value === 'object');
                objects.forEach(([toplevelKey, toplevel]) => {
                    const found = Object.entries(toplevel).find(([_, value]) => (
                        value && typeof value === 'object' && 'sitekey' in value && 'size' in value
                    ));
                    if (typeof toplevel === 'object' && toplevel instanceof HTMLElement && toplevel['tagName'] === 'DIV'){
                        data.pageurl = toplevel.baseURI;
                    }
                    if (found) {
                        const [sublevelKey, sublevel] = found;

						data.sitekey = sublevel.sitekey;
						const callbackKey = data.version === 'V2' ? 'callback' : 'promise-callback';
						const callback = sublevel[callbackKey];
						if (!callback) {
							data.callback = null;
							data.function = null;
						} else {
							data.function = callback;
							const keys = [cid, toplevelKey, sublevelKey, callbackKey].map((key) => `['${key}']`).join('');
							data.callback = `___grecaptcha_cfg.clients${keys}`;
						}
					}
				});
				return data;
			});
		}
		return [];
	});
	// return result
	let callback_function = result[0].callback;
	debug && console.log('[captcha.io] callback_function:', callback_function);

    // generate a random token of the form 
    let captchaToken = generateToken();
    debug && console.log('[captcha.io] captchaToken:', captchaToken);
	// make the id g-recaptcha-response visible
	await page.evaluate( ({ captchaToken }) => {
        // make textarea visible
        document.getElementById("g-recaptcha-response").style.display = "block";
		document.getElementById("g-recaptcha-response").value = captchaToken;	
	}, { captchaToken });
    
    await page.evaluate( ({ captchaToken, callback_function }) => {
        let callback = eval(callback_function);
        if(typeof callback === 'function') {
            callback(captchaToken);
        }
    }, { captchaToken, callback_function });

    // run callback function 
    return true
}


export default captcha_solver;


